<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat</title>
  <style>
:root {
  --bg: #fff;
  --text: #000;
  --muted: #666;
  --border: #000;
  --accent: #0084ff;
  --gap: 12px;
}

[data-theme="dark"] {
  --bg: #0b0f14;
  --text: #f5f5f5;
  --muted: #888;
  --border: #444;
  --accent: #0af;
}

* {
  box-sizing: border-box;
  transition: background 0.25s, color 0.25s, border-color 0.25s;
}

html, body {
  height: 100%;
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
}

h1, h2 {
  margin: 0 0 8px 0;
  font-weight: bold;
  letter-spacing: 1px;
  text-transform: uppercase;
  border-bottom: 1px solid var(--border);
  padding-bottom: 4px;
}

.container {
  display: grid;
  grid-template-columns: 280px 1fr;
  gap: var(--gap);
  padding: 14px;
  height: 100vh;
}

header {
  grid-column: 1 / -1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border);
  margin-bottom: 6px;
}

.panel {
  border: 1px solid var(--border);
  padding: 12px;
  background: transparent;
}

.groups {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: 40vh;
  overflow: auto;
  margin-bottom: 8px;
}

.groupItem {
  padding: 6px;
  border: 1px solid var(--border);
  cursor: pointer;
  background: none;
}
.groupItem.active {
  background: var(--text);
  color: var(--bg);
}

.controls {
  display: flex;
  gap: 6px;
  margin-top: 6px;
}

.controls input,
.msgForm input,
.authPanel input {
  flex: 1;
  padding: 6px;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--text);
  font-family: inherit;
}

button {
  padding: 6px 8px;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--text);
  font-family: inherit;
  cursor: pointer;
  text-transform: uppercase;
  font-weight: bold;
}
button:hover {
  background: var(--text);
  color: var(--bg);
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.chatPanel {
  display: flex;
  flex-direction: column;
  height: calc(100vh - 160px);
}

.chatWindow {
  flex: 1;
  border: 1px solid var(--border);
  padding: 12px;
  overflow: auto;
  white-space: pre-wrap;
  line-height: 1.4;
}

.chatLine {
  margin: 0 0 6px 0;
}

.msgForm {
  display: flex;
  gap: 6px;
  margin-top: 8px;
}

.authPanel {
  position: absolute;
  right: 16px;
  top: 72px;
  width: 260px;
  padding: 12px;
  border: 1px solid var(--border);
  background: var(--bg);
}

.authBtns {
  display: flex;
  gap: 6px;
  justify-content: space-between;
}

.hint {
  color: var(--muted);
  font-size: 12px;
  margin-top: 8px;
}

@media (max-width: 700px) {
  .container {
    grid-template-columns: 1fr;
  }
  .authPanel {
    position: static;
    width: 100%;
    margin-top: 8px;
  }
}

  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>Chat</h1>
      <div id="userArea">
        <span id="showUser"></span>
        <button id="logoutBtn" style="display:none">Logout</button>
      </div>
    </header>

    <section class="left">
      <div class="panel">
        <h2>Groups</h2>
        <div id="groupsList" class="groups">(loading...)</div>

        <div class="controls">
          <input id="newGroupName" placeholder="Group name" />
          <button id="createGroupBtn">Create</button>
        </div>

        <div class="controls">
          <input id="inviteCode" placeholder="Invite code" />
          <button id="joinBtn">Join</button>
        </div>

        <div style="margin-top:8px;font-size:12px;color:var(--muted)">
          Invite codes are 8-char codes. Groups are invite-only (people need the code).
        </div>
      </div>
      <div class="panel">
        <h2>Settings</h2>
        <button onclick="toggleTheme()">Toggle Dark / Light mode</button>
        <label for="bgColorPicker">Background: </label>
        <input type="color" id="bgColorPicker" value="#121212">
      </div>
    </section>

    <section class="right">
      <div class="panel chatPanel">
        <div id="chatHeader"></div>
        <div id="chat" class="chatWindow" aria-live="polite"></div>

        <form id="msgForm" class="msgForm">
          <input id="msgInput" autocomplete="off" placeholder="Type a message..." />
          <button id="sendBtn">Send</button>
        </form>
      </div>
    </section>

    <div id="auth" class="authPanel panel">
      <h2>Sign in / Register</h2>
      <input id="username" placeholder="username (3-24, letters/numbers/_-. )" />
      <input id="password" type="password" placeholder="password (min 6)" />
      <div class="authBtns">
        <button id="login">Login</button>
        <button id="register">Register</button>
      </div>
      <p class="hint">Usernames are unique and can't be reused. Passwords are handled by Firebase Auth (secure).</p>
    </div>
  </main>

  <!-- Firebase compat SDKs (easy for single-file deployment) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.1.0/firebase-app.js';
import { getDatabase, ref, set, push, onValue, get, update } from 'https://www.gstatic.com/firebasejs/10.1.0/firebase-database.js';

const firebaseConfig = {
  apiKey: "AIzaSyC4HaUzTDQsz1AKUCsv1ieY5G9WrCyTHrw",
  authDomain: "website-11b5c.firebaseapp.com",
  databaseURL: "https://website-11b5c-default-rtdb.firebaseio.com",
  projectId: "website-11b5c",
  storageBucket: "website-11b5c.firebasestorage.app",
  messagingSenderId: "821866548441",
  appId: "1:821866548441:web:00a08e534699a6f97902c8"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// === DOM Elements ===
let groupMessageListener = null;
const msgInput = document.getElementById('msgInput');
const sendBtn = document.getElementById('sendBtn');
const usernameInput = document.getElementById('username');
const passwordInput = document.getElementById('password');
const registerBtn = document.getElementById('register');
const loginBtn = document.getElementById('login');
const createGroupBtn = document.getElementById('createGroupBtn');
const joinGroupBtn = document.getElementById('joinBtn');
const groupListDiv = document.getElementById('groupsList');
const messages = document.getElementById('chat');
const authPanel = document.getElementById('auth');
const showUser = document.getElementById('showUser');
const logoutBtn = document.getElementById('logoutBtn');
const chatHeader = document.getElementById('chatHeader');

let currentUser = null;
let currentGroupId = null;
let currentGroupData = null; // group metadata (owner, inviteOnly, members, mute...)

// === Simple cookie handling ===
function setCookie(name, value, days = 365) {
  const d = new Date();
  d.setTime(d.getTime() + days * 864e5);
  document.cookie = `${name}=${encodeURIComponent(value)};path=/;expires=${d.toUTCString()}`;
}
function getCookie(name) {
  const m = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));
  return m ? decodeURIComponent(m[1]) : null;
}

// === Helper: system message ===
async function postSystemMessage(groupId, text) {
  const newMsgRef = push(ref(db, 'retro/messages/' + groupId));
  await set(newMsgRef, { sender: 'â€”systemâ€”', text, ts: Date.now(), system: true });
}

// === Auth ===
registerBtn.onclick = async () => {
  const name = usernameInput.value.trim();
  const pass = passwordInput.value.trim();
  if (!name || !pass) return alert('Enter both fields');

  // NOTE: simple password storage like this is only for demo; production should use Firebase Auth.
  await set(ref(db, 'retro/users/' + name), { password: pass });
  setCookie('username', name);
  currentUser = name;
  authPanel.style.display = 'none';
  showUser.textContent = name;
  logoutBtn.style.display = 'inline';
  loadGroups();
};

loginBtn.onclick = async () => {
  const name = usernameInput.value.trim();
  const pass = passwordInput.value.trim();
  const snap = await get(ref(db, 'retro/users/' + name));
  if (!snap.exists()) return alert('User not found');
  if (snap.val().password !== pass) return alert('Wrong password');

  setCookie('username', name);
  currentUser = name;
  authPanel.style.display = 'none';
  showUser.textContent = name;
  logoutBtn.style.display = 'inline';
  loadGroups();
};

logoutBtn.onclick = () => {
  document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
  currentUser = null;
  authPanel.style.display = 'block';
  logoutBtn.style.display = 'none';
  currentGroupId = null;
  currentGroupData = null;
  chatHeader.textContent = '';
  messages.innerHTML = '';
};

// === Groups ===
function loadGroups() {
  const groupsRef = ref(db, 'retro/groups');
  onValue(groupsRef, snapshot => {
    groupListDiv.innerHTML = '';
    const data = snapshot.val() || {};

    for (const id in data) {
      const group = data[id];
      const isMember = group.members && currentUser && group.members[currentUser];

      // Show if public OR user is member
      if (!group.inviteOnly || isMember) {
        const div = document.createElement('div');
        const unreadCount = parseInt(localStorage.getItem(`unread_${id}`)) || 0;
        div.textContent = group.name + (group.inviteOnly ? ` ðŸ”’${unreadCount > 0 ? ' (' + unreadCount + ')' : ''}` : '');
        div.className = 'groupItem';
        div.onclick = () => selectGroup(id);
        groupListDiv.appendChild(div);
      }
    }
  });
}

function incrementUnread(groupId) {
  const key = `unread_${groupId}`;
  const current = parseInt(localStorage.getItem(key)) || 0;
  localStorage.setItem(key, current + 1);
  loadGroups(); // refresh the list
}

function resetUnread(groupId) {
  localStorage.setItem(`unread_${groupId}`, 0);
  loadGroups(); // refresh the list
}

// Create group
createGroupBtn.onclick = async () => {
  if (!currentUser) return alert('Login first');
  const name = document.getElementById('newGroupName').value.trim();
  if (!name) return alert('Enter a group name');

  const isInviteOnly = confirm('Make this group invite-only?');
  const inviteCode = isInviteOnly ? Math.random().toString(36).slice(2, 10) : null;

  const id = 'g_' + Math.random().toString(36).slice(2, 10);
  await set(ref(db, `retro/groups/${id}`), {
    name,
    owner: currentUser,
    inviteOnly: isInviteOnly,
    inviteCode,
    members: { [currentUser]: true },
    mute: { type: 'none' } // default
  });

  if (isInviteOnly) alert('Invite code: ' + inviteCode);
};

// Join group
joinGroupBtn.onclick = async () => {
  if (!currentUser) return alert('Login first');

  const code = document.getElementById('inviteCode').value.trim();
  if (!code) return alert('Enter an invite code');

  const groupsRef = ref(db, 'retro/groups');
  const snapshot = await get(groupsRef);
  const groups = snapshot.val() || {};

  const groupId = Object.keys(groups).find(id => groups[id].inviteCode === code);
  if (!groupId) return alert('Invalid invite code');

  // Add user as member
  await set(ref(db, `retro/groups/${groupId}/members/${currentUser}`), true);

  // Open the chat
  selectGroup(groupId);
  alert('Joined group: ' + groups[groupId].name);

  // ðŸ”¹ Reload groups so the new group appears in the list
  loadGroups();
};

// === Messages & group selection ===
function selectGroup(id) {
  // âœ… Remove previous message listener so other groups donâ€™t hijack the chat
  if (groupMessageListener) {
    groupMessageListener(); // unsubscribe from previous onValue listener
    groupMessageListener = null;
  }

  // clear previous listeners/state
  currentGroupId = id;
  resetUnread(id);
  currentGroupData = null;
  messages.innerHTML = '';
  chatHeader.textContent = 'Loading...';

  // Load group metadata (owner, name, mute state)
  (async () => {
    const gSnap = await get(ref(db, `retro/groups/${id}`));
    if (!gSnap.exists()) {
      chatHeader.textContent = 'Group not found';
      return;
    }
    currentGroupData = gSnap.val();
    chatHeader.innerHTML = `<strong>${escapeHtml(currentGroupData.name || 'Unnamed')}</strong>
                            <div style="font-size:12px;color:var(--muted)">owner: ${escapeHtml(currentGroupData.owner || 'n/a')}</div>`;
  })();

  const msgsRef = ref(db, 'retro/messages/' + id);

  // âœ… Save unsubscribe function so we can stop listening next time
  groupMessageListener = onValue(msgsRef, snapshot => {
    messages.innerHTML = '';
    const msgs = snapshot.val() || {};
    for (const mid in msgs) {
      const { sender, text, ts, system } = msgs[mid];

      // Skip messages if they are muted by group mute rules
      if (currentGroupData && isMessageMutedByGroup(sender, currentGroupData.mute)) {
        continue;
      }

      const line = document.createElement('div');
      line.className = 'chatLine';

      const msgSpan = document.createElement('span');
      msgSpan.textContent = `${sender} > ${text}`;

      const timeSpan = document.createElement('span');
      const time = ts ? formatTimestamp(ts) : '';
      timeSpan.textContent = time;
      timeSpan.style.color = 'var(--muted)';
      timeSpan.style.fontSize = '12px';
      timeSpan.style.marginLeft = '8px';
      timeSpan.style.whiteSpace = 'nowrap';

      line.style.display = 'flex';
      line.style.justifyContent = 'space-between';
      line.style.alignItems = 'center';

      // System messages styling
      if (system) {
        msgSpan.style.fontStyle = 'italic';
        msgSpan.style.color = 'var(--muted)';
      }

      line.appendChild(msgSpan);
      line.appendChild(timeSpan);
      messages.appendChild(line);
    }

    // ðŸ”” Only increment unread count, donâ€™t auto-switch
    if (currentGroupId !== id && currentGroupData && currentGroupData.inviteOnly) {
      incrementUnread(id);
    }

    messages.scrollTop = messages.scrollHeight;
  });
}

// Format timestamp to "Nov 5, 2025 Â· 12:34 PM"
function formatTimestamp(ts) {
  const d = new Date(ts);
  const date = d.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
  const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  return `${date} Â· ${time}`;
}

// Check mute rules
function isMessageMutedByGroup(sender, mute) {
  if (!mute || mute.type === 'none') return false;

  if (mute.type === 'user') {
    // target is muted
    return sender === mute.target;
  }

  if (mute.type === 'everyone_except') {
    // everyone except target is muted
    return sender !== mute.target;
  }

  if (mute.type === 'everyone') {
    return true;
  }

  return false;
}

// send handler (including commands)
sendBtn.onclick = async e => {
  e.preventDefault();
  if (!currentGroupId || !currentUser) return;

  const textRaw = msgInput.value.trim();
  if (!textRaw) return;

  // Command syntax starts with //
  if (textRaw.startsWith('//')) {
    // Only owner can run commands
    const groupRef = ref(db, `retro/groups/${currentGroupId}`);
    const gSnap = await get(groupRef);
    const g = gSnap.exists() ? gSnap.val() : null;
    if (!g) return alert('Group not found');

    if (g.owner !== currentUser) return alert('Only the group owner can run commands.');

    // parse command
    const parts = textRaw.slice(2).trim().split(' ');
    const command = parts[0].toLowerCase();
    const rest = parts.slice(1).join(' ').trim();

    if (command === 'ban') {
      const target = rest;
      if (!target) return alert('Usage: //ban username');
      // remove member entry
      await set(ref(db, `retro/groups/${currentGroupId}/members/${target}`), null);
      await postSystemMessage(currentGroupId, `${target} was banned by ${currentUser}.`);
      // If the banned user is the current viewer, kick them out
      if (target === currentUser) {
        alert('You banned yourself (you are no longer a member).');
        currentGroupId = null;
        currentGroupData = null;
        messages.innerHTML = '';
        chatHeader.textContent = '';
      }
        } else if (command === 'makesilent') {
      if (!rest) return alert('Usage: //makesilent username  OR  //makesilent !username (everyone except username)');

      if (rest.startsWith('!')) {
        const exceptUser = rest.slice(1);
        if (!exceptUser) return alert('Specify a username after !');
        await update(ref(db, `retro/groups/${currentGroupId}`), { mute: { type: 'everyone_except', target: exceptUser } });
        await postSystemMessage(currentGroupId, `All users silenced except ${exceptUser} (by ${currentUser}).`);
      } else {
        const target = rest;
        await update(ref(db, `retro/groups/${currentGroupId}`), { mute: { type: 'user', target } });
        await postSystemMessage(currentGroupId, `${target} has been silenced (by ${currentUser}).`);
      }

    } else if (command === 'unsilent') {
      if (!rest) return alert('Usage: //unsilent username');

      const target = rest.trim();

      const groupRef = ref(db, `retro/groups/${currentGroupId}`);
      const snapshot = await get(ref(db, `retro/groups/${currentGroupId}/mute`));

      if (!snapshot.exists()) return alert('No mute data found for this group.');

      const muteData = snapshot.val();

      if (muteData.type === 'user' && muteData.target === target) {
        await update(groupRef, { mute: { type: 'none' } });
        await postSystemMessage(currentGroupId, `${target} has been unsilenced by ${currentUser}.`);
      } else if (muteData.type === 'everyone_except' && muteData.target === target) {
        await update(groupRef, { mute: { type: 'everyone' } });
        await postSystemMessage(currentGroupId, `${target} has been unsilenced by ${currentUser}.`);
      } else {
        await postSystemMessage(currentGroupId, `${target} is not currently silenced.`);
      }
    } else if (command === 'rename') {
      const newName = rest.trim();
      if (!newName) return alert('Usage: //rename New Group Name');
    
      // Update group name in the database
      await update(ref(db, `retro/groups/${currentGroupId}`), { name: newName });
    
      // Update currentGroupData locally so header updates immediately
      currentGroupData.name = newName;
      chatHeader.innerHTML = `<strong>${escapeHtml(currentGroupData.name || 'Unnamed')}</strong>
                              <div style="font-size:12px;color:var(--muted)">owner: ${escapeHtml(currentGroupData.owner || 'n/a')}</div>`;
    
      // Post system message
      await postSystemMessage(currentGroupId, `Group name changed to "${newName}" by ${currentUser}.`);
    } else {
      return alert('Unknown command.');
    }

    msgInput.value = '';
    return;
  }

  // Normal message: check if the sender is allowed (not silenced)
  const groupSnap = await get(ref(db, `retro/groups/${currentGroupId}`));
  const gdata = groupSnap.exists() ? groupSnap.val() : null;
  if (gdata && isMessageMutedByGroup(currentUser, gdata.mute)) {
    return alert('You are currently silenced in this group and cannot send messages.');
  }

  const newMsgRef = push(ref(db, 'retro/messages/' + currentGroupId));
  await set(newMsgRef, { sender: currentUser, text: textRaw, ts: Date.now() });
  msgInput.value = '';
};

// === Auto-login ===
const cookieUser = getCookie('username');
if (cookieUser) {
  currentUser = cookieUser;
  authPanel.style.display = 'none';
  showUser.textContent = cookieUser;
  logoutBtn.style.display = 'inline';
  loadGroups();
}

// === Theme toggle ===
window.toggleTheme = function() {
  const root = document.documentElement;
  const isDark = root.dataset.theme === 'dark';
  root.dataset.theme = isDark ? 'light' : 'dark';
  localStorage.setItem('theme', isDark ? 'light' : 'dark');
};

// === Background color selector ===
const bgColorPicker = document.getElementById('bgColorPicker');

// When user selects a background color
bgColorPicker.addEventListener('input', (e) => {
  const color = e.target.value;
  document.documentElement.style.setProperty('--bg', color);
  localStorage.setItem('customBgColor', color);
});

// Apply saved color on load
const savedBg = localStorage.getItem('customBgColor');
if (savedBg) {
  document.documentElement.style.setProperty('--bg', savedBg);
  bgColorPicker.value = savedBg;
}

// Restore saved theme on load
document.documentElement.dataset.theme = localStorage.getItem('theme') || 'light';

// small helper to escape HTML when injecting names etc.
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
</script>

</body>
</html>
