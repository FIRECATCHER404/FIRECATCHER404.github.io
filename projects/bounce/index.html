<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Water-Like Blocks</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

let scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(40, 40, 40);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

let light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 20, 10);
scene.add(light, new THREE.AmbientLight(0x404040));

const gridSize = 100;
const spacing = 1.1;
const blocks = [];
const heights = [];
const velocities = [];

// geometry + material
let geometry = new THREE.BoxGeometry(1, 8, 1);
let material = new THREE.MeshStandardMaterial({color:0xffffff});

// create grid
for (let x = 0; x < gridSize; x++) {
  blocks[x] = [];
  heights[x] = [];
  velocities[x] = [];
  for (let z = 0; z < gridSize; z++) {
    let mesh = new THREE.Mesh(geometry, material.clone());
    mesh.position.set(
      (x - gridSize/2) * spacing,
      0,
      (z - gridSize/2) * spacing
    );
    mesh.userData.baseY = 0;
    scene.add(mesh);
    blocks[x][z] = mesh;
    heights[x][z] = 0;   // displacement from base
    velocities[x][z] = 0;
  }
}

let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();

window.addEventListener("mousedown", (e) => {
  if (e.button !== 0) return; // only middle-click
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  let intersects = raycaster.intersectObjects(blocks.flat());
  if (intersects.length > 0) {
    let clicked = intersects[0].object;
    triggerRipple(clicked);
  }
});

function triggerRipple(clicked) {
  for (let x = 0; x < gridSize; x++) {
    for (let z = 0; z < gridSize; z++) {
      if (blocks[x][z] === clicked) {
        velocities[x][z] = 10; // kick up velocity
      }
    }
  }
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();

  let damping = 0.99;    // keep same
  let spread = 1.6;      // keep same
  let timeScale = 0.09;   // <--- lower = slower motion (1.0 = normal speed)

  // copy of heights for stable updates
  let newHeights = heights.map(arr => arr.slice());

  for (let x = 1; x < gridSize-1; x++) {
    for (let z = 1; z < gridSize-1; z++) {
      // average of neighbors
      let sum = heights[x-1][z] + heights[x+1][z] + heights[x][z-1] + heights[x][z+1];
      let avg = sum / 4;

      // velocity update scaled by time
      velocities[x][z] += (avg - heights[x][z]) * spread * timeScale;
      velocities[x][z] *= Math.pow(damping, timeScale);

      newHeights[x][z] += velocities[x][z] * timeScale;

      blocks[x][z].position.y = newHeights[x][z];
    }
  }

  // swap buffers
  for (let x = 0; x < gridSize; x++) {
    for (let z = 0; z < gridSize; z++) {
      heights[x][z] = newHeights[x][z];
    }
  }

  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
