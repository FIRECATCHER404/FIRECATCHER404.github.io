<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Minecraft-like Terrain — 500x500 blocks</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#202020; color: #ddd; font-family:Inter,Segoe UI,Arial; }
    #ui { position: absolute; left: 12px; top: 12px; z-index: 10; background: rgba(0,0,0,0.35); padding:10px; border-radius:8px; }
    #info { font-size:13px; margin-bottom:8px; }
    button, input[type=checkbox] { margin-right:8px; }
    #canvasHolder { width:100%; height:100%; overflow:hidden; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="info">
      <strong>Minecraft-like terrain</strong><br>
      World: <span id="worldSize">500 × 500</span> columns • block = 1 × 1 × 1 (units = inches)<br>
      Controls: left-drag rotate, middle/scroll zoom, right-drag pan (OrbitControls)
    </div>
    <label><input id="seedInput" type="number" value="12345" /> seed</label>
    <label><input id="toggleFullCols" type="checkbox" /> Full columns (very heavy)</label>
    <label><input id="regenerateBtn" type="button" value="Regenerate" /></label>
    <div style="margin-top:6px;font-size:12px;color:#bbb">
      Tip: rotate the view and use the checkbox to compare visual modes.
    </div>
  </div>
  <div id="canvasHolder"></div>

  <!-- Three.js (module import) -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Simplex / Perlin noise: small implementation (improved noise by Stefan Gustavson port)
    // This is a compact 2D simplex noise implementation used only for terrain generation.
    // Source adapted for in-file use (public domain style compact variant).
    class SimplexNoise {
      constructor(seed = 0) {
        this.p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) this.p[i] = i;
        // simple seed shuffle (not cryptographically strong but deterministic)
        let s = seed = Number(seed) | 0;
        for (let i = 255; i > 0; i--) {
          s = (s * 1664525 + 1013904223) | 0;
          const r = (s >>> 0) % (i + 1);
          const tmp = this.p[i];
          this.p[i] = this.p[r];
          this.p[r] = tmp;
        }
        this.perm = new Uint8Array(512);
        for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
        this.grad3 = [
          [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
          [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
          [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
        ];
      }

      dot(g, x, y) { return g[0]*x + g[1]*y; }

      noise2D(xin, yin) {
        const F2 = 0.5*(Math.sqrt(3.0)-1.0);
        const G2 = (3.0-Math.sqrt(3.0))/6.0;
        let n0=0, n1=0, n2=0;
        const s = (xin+yin)*F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const t = (i + j)*G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;
        const i1 = x0 > y0 ? 1 : 0;
        const j1 = x0 > y0 ? 0 : 1;
        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2;
        const y2 = y0 - 1.0 + 2.0 * G2;
        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
        const t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 >= 0) {
          const tt = (t0*t0);
          n0 = tt * tt * this.dot(this.grad3[gi0], x0, y0);
        }
        const t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 >= 0) {
          const tt = (t1*t1);
          n1 = tt * tt * this.dot(this.grad3[gi1], x1, y1);
        }
        const t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 >= 0) {
          const tt = (t2*t2);
          n2 = tt * tt * this.dot(this.grad3[gi2], x2, y2);
        }
        return 70.0 * (n0 + n1 + n2);
      }
    }

    // ---------- Config ----------
    const WORLD_SIZE = 100;         // X and Z size
    const BLOCK_SIZE = 1.0;         // 1 unit = 1 inch (visual scale)
    const MAX_HEIGHT = 120;         // maximum block height in columns (tweak)
    const HEIGHT_SCALE = 32;        // scales noise output to heights
    const NOISE_FREQ = 0.0085;      // frequency for noise (controls mountains)
    // ----------------------------

    // Get UI elements
    const canvasHolder = document.getElementById('canvasHolder');
    const regenerateBtn = document.getElementById('regenerateBtn');
    const seedInput = document.getElementById('seedInput');
    const toggleFullCols = document.getElementById('toggleFullCols');
    const worldSizeSpan = document.getElementById('worldSize');
    worldSizeSpan.textContent = `${WORLD_SIZE} × ${WORLD_SIZE}`;

    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // sky-ish
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    canvasHolder.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(WORLD_SIZE * 0.8, MAX_HEIGHT * 1.3, WORLD_SIZE * 0.8);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(WORLD_SIZE/2, 10, WORLD_SIZE/2);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.screenSpacePanning = false;

    window.addEventListener('resize', onWindowResize);
    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Lights
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(0.6, 1, 0.3).normalize();
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    // Materials for types
    const matGrass = new THREE.MeshLambertMaterial({ color: 0x48a23f });
    const matDirt = new THREE.MeshLambertMaterial({ color: 0x7a4e2b });
    const matStone = new THREE.MeshLambertMaterial({ color: 0x7f7f7f });
    const matCliff = new THREE.MeshLambertMaterial({ color: 0x7a6b4f });

    // Reusable geometries
    const cubeGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    // plane for vertical faces (1 x h)
    const planeGeo = new THREE.PlaneGeometry(BLOCK_SIZE, 1.0);

    // Instanced mesh containers (we'll recreate when regenerating)
    let topInstanced = null;
    let cliffInstanced = null;
    let fullInstanced = null; // used for full columns (very heavy)

    // Helper: color selection based on height
    function materialForHeight(h) {
      if (h > 48) return matStone;
      if (h > 12) return matDirt;
      return matGrass;
    }

    // Generate heightmap using simplex noise
    function generateHeightmap(seed) {
      const noise = new SimplexNoise(seed | 0);

      // allocate typed array heights (WORLD_SIZE x WORLD_SIZE)
      const heights = new Int16Array(WORLD_SIZE * WORLD_SIZE);
      for (let z = 0; z < WORLD_SIZE; z++) {
        for (let x = 0; x < WORLD_SIZE; x++) {
          // combine multiple octaves for richer terrain
          let nx = x * NOISE_FREQ;
          let nz = z * NOISE_FREQ;
          let e = 0;
          let amp = 1.0, freq = 1.0, pers = 0.55;
          let octaves = 5;
          for (let o = 0; o < octaves; o++) {
            e += amp * noise.noise2D(nx * freq, nz * freq);
            amp *= pers;
            freq *= 2.0;
          }
          // normalize e roughly into [ -1 , 1 ] then map to height
          const height = Math.floor((e * 0.5 + 0.5) * HEIGHT_SCALE);
          const hclamped = Math.max(1, Math.min(MAX_HEIGHT, height));
          heights[z * WORLD_SIZE + x] = hclamped;
        }
      }
      return heights;
    }

    // Build instanced meshes from heightmap
    function buildMeshes(heights, drawFullColumns = false) {
      // Clean old
      if (topInstanced) { scene.remove(topInstanced); topInstanced.geometry.dispose(); }
      if (cliffInstanced) { scene.remove(cliffInstanced); cliffInstanced.geometry.dispose(); }
      if (fullInstanced) { scene.remove(fullInstanced); fullInstanced.geometry.dispose(); }

      // Top cubes: one cube per column (visual top block)
      const totalTop = WORLD_SIZE * WORLD_SIZE;
      topInstanced = new THREE.InstancedMesh(cubeGeo, matGrass, totalTop);
      topInstanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(topInstanced);

      // For cliffs: we place vertical plane instances (one per exposed side)
      // worst-case 4 sides per column * columns
      const maxCliffSides = WORLD_SIZE * WORLD_SIZE * 4;
      // We'll use a single material for cliff sides
      cliffInstanced = new THREE.InstancedMesh(planeGeo, matCliff, maxCliffSides);
      cliffInstanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      cliffInstanced.geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, -0.5, 0)); // pivot at bottom

      scene.add(cliffInstanced);

      // Optionally full columns (very heavy) — create an InstancedMesh that stores all cubes
      let fullCount = 0;
      if (drawFullColumns) {
        // rough count
        for (let i = 0; i < heights.length; i++) fullCount += heights[i];
        fullInstanced = new THREE.InstancedMesh(cubeGeo, matDirt, fullCount);
        fullInstanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(fullInstanced);
      }

      // Populate instances
      let topIdx = 0;
      let cliffIdx = 0;
      let fullIdx = 0;
      const dummy = new THREE.Object3D();
      const q = new THREE.Quaternion();

      // neighbor helper
      function getH(x, z) {
        if (x < 0 || x >= WORLD_SIZE || z < 0 || z >= WORLD_SIZE) return 0;
        return heights[z * WORLD_SIZE + x];
      }

      for (let z = 0; z < WORLD_SIZE; z++) {
        for (let x = 0; x < WORLD_SIZE; x++) {
          const h = heights[z * WORLD_SIZE + x];

          // TOP cube (place top-most block centered on its block position)
          dummy.position.set(
            x * BLOCK_SIZE + BLOCK_SIZE/2,
            (h - 1) * BLOCK_SIZE + BLOCK_SIZE/2,
            z * BLOCK_SIZE + BLOCK_SIZE/2
          );
          dummy.scale.set(1,1,1);
          dummy.updateMatrix();
          topInstanced.setMatrixAt(topIdx++, dummy.matrix);

          // color / material for the top instance (can't set per-instance material easily)
          // workaround: for visual variety we tint vertex colors? Simpler: set topInstanced.material to basic
          // We'll cheat by using different meshes for bands (not doing here because too many draws).
          // Instead we leave top as grass color and add subtle lighting.

          // Cliffs: check 4 neighbors, if neighbor height < h then place vertical planes for the exposed faces
          const dirs = [
            {dx: 0, dz: -1, rotY: 0},     // north (-z)
            {dx: 1, dz: 0, rotY: Math.PI/2},  // east (+x)
            {dx: 0, dz: 1, rotY: Math.PI}, // south (+z)
            {dx: -1, dz: 0, rotY: -Math.PI/2} // west (-x)
          ];
          for (let d = 0; d < 4; d++) {
            const nx = x + dirs[d].dx;
            const nz = z + dirs[d].dz;
            const nh = getH(nx, nz);
            if (nh < h) {
              // for each vertical face, we may need multiple plane instances stacked to cover the vertical drop
              const drop = h - nh;
              for (let row = 0; row < drop; row++) {
                // position bottom of this plane
                const py = (nh + row) * BLOCK_SIZE + BLOCK_SIZE/2;
                // plane is 1 wide x 1 tall, we will rotate to face outward and translate slightly so it's flush with block edge
                dummy.position.set(
                  x * BLOCK_SIZE + BLOCK_SIZE/2 + (dirs[d].dx * BLOCK_SIZE/2),
                  py,
                  z * BLOCK_SIZE + BLOCK_SIZE/2 + (dirs[d].dz * BLOCK_SIZE/2)
                );
                dummy.scale.set(1,1,1);
                q.setFromAxisAngle(new THREE.Vector3(0,1,0), dirs[d].rotY);
                dummy.quaternion.copy(q);
                dummy.updateMatrix();
                cliffInstanced.setMatrixAt(cliffIdx++, dummy.matrix);
              }
            }
          }

          // If user requested full columns, instantiate every cube in column (heavy)
          if (drawFullColumns) {
            for (let y = 0; y < h; y++) {
              dummy.position.set(
                x * BLOCK_SIZE + BLOCK_SIZE/2,
                y * BLOCK_SIZE + BLOCK_SIZE/2,
                z * BLOCK_SIZE + BLOCK_SIZE/2
              );
              dummy.updateMatrix();
              fullInstanced.setMatrixAt(fullIdx++, dummy.matrix);
            }
          }
        }
      }

      // set counts (important) — tell instanced meshes how many instances are valid
      topInstanced.count = topIdx;
      cliffInstanced.count = cliffIdx;
      if (fullInstanced) fullInstanced.count = fullIdx;

      // update instance matrix attribute range
      topInstanced.instanceMatrix.needsUpdate = true;
      cliffInstanced.instanceMatrix.needsUpdate = true;
      if (fullInstanced) fullInstanced.instanceMatrix.needsUpdate = true;

      // Add a ground grid for reference
      addReferenceGrid();
    }

    // Add/remove old grid
    let gridHelper = null;
    function addReferenceGrid() {
      if (gridHelper) { scene.remove(gridHelper); }
      gridHelper = new THREE.GridHelper(WORLD_SIZE * BLOCK_SIZE, WORLD_SIZE, 0x000000, 0x000000);
      gridHelper.material.opacity = 0.15;
      gridHelper.material.transparent = true;
      gridHelper.position.set(WORLD_SIZE*BLOCK_SIZE/2, 0, WORLD_SIZE*BLOCK_SIZE/2);
      scene.add(gridHelper);
    }

    // Initial generation
    function regenerate() {
      const seed = Number(seedInput.value) || 0;
      const heights = generateHeightmap(seed);
      const drawFull = toggleFullCols.checked;
      buildMeshes(heights, drawFull);
      // reposition camera target center
      controls.target.set(WORLD_SIZE * BLOCK_SIZE / 2, 10, WORLD_SIZE * BLOCK_SIZE / 2);
      controls.update();
    }

    // UI bindings
    regenerateBtn.addEventListener('click', () => {
      regenerate();
    });

    toggleFullCols.addEventListener('change', () => {
      // Rebuild when toggling heavy mode
      regenerate();
      if (toggleFullCols.checked) {
        alert('Full columns mode will be very heavy — may freeze your browser. Use for small seeds/test only.');
      }
    });

    // initial call
    regenerate();

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Keyboard shortcuts for quick navigation (optional)
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r') regenerate();
      if (e.key === 'f') {
        toggleFullCols.checked = !toggleFullCols.checked;
        regenerate();
      }
    });

  </script>
</body>
</html>
