<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Procedural Planet Generator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    #canvas-container{width:100%;height:100%;position:relative;overflow:hidden}
    #ui {
      position:absolute;
      right:12px;
      top:12px;
      width:260px;
      background:rgba(0,0,0,0.45);
      padding:12px;border-radius:10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }
    #ui h3{margin:0 0 8px 0;font-size:14px}
    .row{display:flex;align-items:center;gap:8px;margin:8px 0}
    .row label{flex:1;font-size:12px}
    .row input[type=range]{flex:2}
    button, input[type=color]{width:100%}
    small{color:#bbb;font-size:11px}
    a { color: #7fbfff }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="ui">
    <a href="../index.html"><button>Main Menu</button></a>
    <h3>Procedural Planet</h3>

    <div class="row">
      <label>Radius</label>
      <input id="radius" type="range" min="1" max="6" step="0.1" value="2">
    </div>

    <div class="row">
      <label>Noise Scale</label>
      <input id="noiseScale" type="range" min="0.2" max="6" step="0.1" value="2.2">
    </div>

    <div class="row">
      <label>Elevation</label>
      <input id="elevation" type="range" min="0" max="1.2" step="0.01" value="0.35">
    </div>

    <div class="row">
      <label>Segments</label>
      <input id="segments" type="range" min="32" max="256" step="16" value="128">
    </div>

    <div class="row">
      <label>Spin (°/s)</label>
      <input id="spin" type="range" min="0" max="120" step="1" value="8">
    </div>

    <div class="row">
      <label>Seed</label>
      <input id="seed" type="number" value="1" style="width:100px">
      <button id="randomize" style="width:120px">Randomize</button>
    </div>

    <div style="margin-top:8px">
      <button id="regenerate">Regenerate Planet</button>
    </div>
    <small style="display:block;margin-top:8px">Tip: drag to rotate, scroll to zoom, right-drag to pan.</small>
  </div>

  <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

  // -----------------------------
  // Simplex/Perlin noise
  // small 3D simplex noise implementation (public domain by Stefan Gustavson, adapted)
  // -----------------------------
  // Implementation below is compact 3D noise — good enough to shape the planet.
  class SimplexNoise {
    constructor(seed = 0) {
      this.p = new Uint8Array(256);
      for (let i = 0; i < 256; i++) this.p[i] = i;
      let n, q;
      seed = seed | 0;
      for (let i = 255; i > 0; i--) {
        seed = (seed * 1664525 + 1013904223) | 0;
        n = (seed + 0x80000000) >>> 0;
        q = n % (i + 1);
        const tmp = this.p[i]; this.p[i] = this.p[q]; this.p[q] = tmp;
      }
      this.perm = new Uint8Array(512);
      for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
    }
    dot(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
    noise3D(xin, yin, zin) {
      const perm = this.perm;
      const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
      const F3 = 1/3, G3 = 1/6;
      let n0=0,n1=0,n2=0,n3=0;
      let s = (xin+yin+zin)*F3; let i = Math.floor(xin+s), j = Math.floor(yin+s), k = Math.floor(zin+s);
      let t = (i+j+k)*G3; let X0 = i-t, Y0 = j-t, Z0 = k-t;
      let x0 = xin - X0, y0 = yin - Y0, z0 = zin - Z0;
      let i1,j1,k1,i2,j2,k2;
      if (x0>=y0) { if (y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } 
        else if (x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } 
        else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } }
      else { if (y0<z0){ i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } 
        else if (x0<z0){ i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } 
        else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } }
      let x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
      let x2 = x0 - i2 + 2*G3, y2 = y0 - j2 + 2*G3, z2 = z0 - k2 + 2*G3;
      let x3 = x0 - 1 + 3*G3, y3 = y0 - 1 + 3*G3, z3 = z0 - 1 + 3*G3;
      const ii = i & 255, jj = j & 255, kk = k & 255;
      let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0; if (t0>0){ let gi0 = perm[ii+perm[jj+perm[kk]]] % 12; t0 *= t0; n0 = t0 * t0 * this.dot(grad3[gi0], x0, y0, z0); }
      let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1; if (t1>0){ let gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12; t1 *= t1; n1 = t1 * t1 * this.dot(grad3[gi1], x1, y1, z1); }
      let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2; if (t2>0){ let gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12; t2 *= t2; n2 = t2 * t2 * this.dot(grad3[gi2], x2, y2, z2); }
      let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3; if (t3>0){ let gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12; t3 *= t3; n3 = t3 * t3 * this.dot(grad3[gi3], x3, y3, z3); }
      return 32*(n0 + n1 + n2 + n3);
    }
  }

  // -----------------------------
  // Scene setup
  // -----------------------------
  const container = document.getElementById('canvas-container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05060a);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 2.5, 6);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  // lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.1);
  dir.position.set(5,10,5);
  scene.add(dir);

  // orbit controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.07;
  controls.minDistance = 2;
  controls.maxDistance = 20;

  // atmosphere (glow) function
  function makeAtmosphere(radius) {
    const geo = new THREE.SphereGeometry(radius * 1.03, 64, 64);
    const mat = new THREE.MeshBasicMaterial({ color: 0x66aaff, transparent: true, opacity: 0.08, side: THREE.BackSide });
    const mesh = new THREE.Mesh(geo, mat);
    return mesh;
  }

  // planet containers
  let planetMesh = null;
  let atmosphereMesh = null;
  let noise = new SimplexNoise(1);

  function buildPlanet(opts) {
    // cleanup
    if (planetMesh) { planetMesh.geometry.dispose(); planetMesh.material.dispose(); scene.remove(planetMesh); planetMesh = null; }
    if (atmosphereMesh) { atmosphereMesh.geometry.dispose(); atmosphereMesh.material.dispose(); scene.remove(atmosphereMesh); atmosphereMesh = null; }

    const radius = opts.radius;
    const seg = Math.max(32, Math.floor(opts.segments));
    const geometry = new THREE.IcosahedronGeometry(radius, Math.round(seg / 32)); // subdivisions => fewer verts for performance
    // convert to buffer geometry with accessible positions/normals
    geometry.computeVertexNormals();

    // copy positions into a regular array for editing
    const pos = geometry.attributes.position;
    const vertex = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
      vertex.fromBufferAttribute(pos, i);
      const normal = vertex.clone().normalize();

      // sample noise in 3D space along the normal
      const sampleFreq = opts.noiseScale;
      const nx = normal.x * sampleFreq + opts.seed * 100;
      const ny = normal.y * sampleFreq + opts.seed * 100;
      const nz = normal.z * sampleFreq + opts.seed * 100;

      // combine several octaves for richer detail
      let e = 0;
      let amp = 1;
      let freq = 1;
      for (let o = 0; o < 4; o++) {
        e += Math.abs(noise.noise3D(nx * freq, ny * freq, nz * freq)) * amp;
        amp *= 0.5;
        freq *= 2.0;
      }
      // normalize value a bit
      e = Math.pow(e, 1.1);

      const displacement = e * opts.elevation;
      const newPos = normal.clone().multiplyScalar(radius + displacement);
      pos.setXYZ(i, newPos.x, newPos.y, newPos.z);
    }

    pos.needsUpdate = true;
    geometry.computeVertexNormals();

    // colorization by height: compute colors
    const colors = new Float32Array(pos.count * 3);
    for (let i = 0; i < pos.count; i++) {
      vertex.fromBufferAttribute(pos, i);
      const height = vertex.length() - radius; // 0..elevation
      // paint: water -> land -> mountain
      let c = new THREE.Color();
      if (height < opts.elevation * 0.15) c.set('#2a4d9f');        // deep water
      else if (height < opts.elevation * 0.18) c.set('#3b77d6');   // shallow
      else if (height < opts.elevation * 0.35) c.set('#4db56a');   // grass
      else if (height < opts.elevation * 0.7) c.set('#8b6a3a');    // rock
      else c.set('#e9e9e9');                                       // snow
      colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
    }
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.MeshStandardMaterial({
      vertexColors: true,
      flatShading: false,
      roughness: 0.9,
      metalness: 0.0
    });

    planetMesh = new THREE.Mesh(geometry, material);
    scene.add(planetMesh);

    atmosphereMesh = makeAtmosphere(radius);
    scene.add(atmosphereMesh);
  }

  // initial build
  const ui = {
    radius: document.getElementById('radius'),
    noiseScale: document.getElementById('noiseScale'),
    elevation: document.getElementById('elevation'),
    segments: document.getElementById('segments'),
    spin: document.getElementById('spin'),
    seed: document.getElementById('seed'),
    randomize: document.getElementById('randomize'),
    regenerate: document.getElementById('regenerate')
  };

  function readSettings() {
    return {
      radius: parseFloat(ui.radius.value),
      noiseScale: parseFloat(ui.noiseScale.value),
      elevation: parseFloat(ui.elevation.value),
      segments: parseInt(ui.segments.value, 10),
      spin: parseFloat(ui.spin.value) * (Math.PI/180), // deg/s -> rad/s
      seed: parseInt(ui.seed.value, 10) || 0
    };
  }

  function regen() {
    const settings = readSettings();
    noise = new SimplexNoise(settings.seed);
    buildPlanet(settings);
  }

  // wire UI
  ui.regenerate.addEventListener('click', () => regen());
  ui.randomize.addEventListener('click', () => {
    const s = Math.floor(Math.random()*100000);
    ui.seed.value = s;
    regen();
  });

  // live rebuild on some changes (segments/elevation/noise)
  ui.radius.addEventListener('input', regen);
  ui.noiseScale.addEventListener('input', regen);
  ui.elevation.addEventListener('input', regen);
  ui.segments.addEventListener('change', regen);
  ui.seed.addEventListener('change', regen);

  // initial call
  regen();

  // animation
  let last = performance.now();
  function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = (now - last) / 1000;
    last = now;

    const s = readSettings();
    // spin planet
    if (planetMesh) planetMesh.rotation.y += s.spin * dt;
    if (atmosphereMesh) atmosphereMesh.rotation.y += s.spin * 0.8 * dt;

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // handle resize
  window.addEventListener('resize', () => {
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
    renderer.setSize(w,h);
  });

  // keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === 'r') regen();
    if (e.key === ' ') {
      camera.position.set(0,2.5,6);
      controls.target.set(0,0,0);
    }
  });

  </script>
</body>
</html>
