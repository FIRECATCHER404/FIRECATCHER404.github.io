<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Abstract 3D Art Generator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{margin:0;overflow:hidden;background:#111;color:#eee}
    #ui{
      position: absolute;
      left: 12px;
      top: 12px;
      width: 320px;
      max-height: calc(100vh - 24px);
      overflow:auto;
      background: rgba(10,10,10,0.6);
      padding:12px;border-radius:10px;
      box-shadow:0 6px 30px rgba(0,0,0,0.6);
      backdrop-filter: blur(6px);
    }
    label{display:block;font-size:12px;margin-top:8px;color:#ddd}
    select,input[type="range"],input[type="number"]{width:100%}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .colors{display:flex;gap:6px;margin-top:6px}
    .color-input{width:48px;height:32px;border:0;padding:0}
    button{margin-top:10px;padding:8px 10px;border-radius:8px;border:0;background:#1e88e5;color:white;cursor:pointer}
    small{color:#9aa}
    #footer{font-size:12px;margin-top:8px;color:#9aa}
  </style>
</head>
<body>
  <div id="ui">
    <label>Style
      <select id="style">
        <option value="ribbons">Ribbons (tube curves)</option>
        <option value="spiky">Spiky Spheres</option>
        <option value="planes">Floating Planes</option>
        <option value="particles">Particle Cloud</option>
      </select>
    </label>

    <label>Count <small id="countLabel">(50)</small>
      <input id="count" type="range" min="1" max="500" value="50">
    </label>

    <label>Global scale <small id="scaleLabel">(1.0)</small>
      <input id="scale" type="range" min="0.1" max="4" step="0.05" value="1">
    </label>

    <label>Animation speed <small id="speedLabel">(1.0)</small>
      <input id="speed" type="range" min="0" max="3" step="0.01" value="1">
    </label>

    <label>Palette (up to 5 colors)</label>
    <div class="colors">
      <input class="color-input" type="color" id="c1" value="#ff616f">
      <input class="color-input" type="color" id="c2" value="#ffd166">
      <input class="color-input" type="color" id="c3" value="#06d6a0">
      <input class="color-input" type="color" id="c4" value="#4d96ff">
      <input class="color-input" type="color" id="c5" value="#c77dff">
    </div>

    <label>Background
      <input id="bg" type="color" value="#0f1720">
    </label>

    <div class="row">
      <button id="regen">Regenerate</button>
      <button id="animateToggle">Pause</button>
    </div>

    <div class="row">
      <button id="randomize">Randomize</button>
      <button id="export">Export PNG</button>
    </div>

    <div id="footer">Tip: drag to orbit, scroll to zoom, right-drag to pan.</div>
  </div>

  <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // scene + camera + renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 6, 18);

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lights
    const amb = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(6,10,8);
    scene.add(dir);

    // UI elements
    const ui = {
      style: document.getElementById('style'),
      count: document.getElementById('count'),
      countLabel: document.getElementById('countLabel'),
      scale: document.getElementById('scale'),
      scaleLabel: document.getElementById('scaleLabel'),
      speed: document.getElementById('speed'),
      speedLabel: document.getElementById('speedLabel'),
      colors: [document.getElementById('c1'), document.getElementById('c2'), document.getElementById('c3'), document.getElementById('c4'), document.getElementById('c5')],
      bg: document.getElementById('bg'),
      regen: document.getElementById('regen'),
      animateToggle: document.getElementById('animateToggle'),
      randomize: document.getElementById('randomize'),
      export: document.getElementById('export')
    };

    // reactive label updates
    function refreshLabels(){
      ui.countLabel.textContent = `(${ui.count.value})`;
      ui.scaleLabel.textContent = `(${parseFloat(ui.scale.value).toFixed(2)})`;
      ui.speedLabel.textContent = `(${parseFloat(ui.speed.value).toFixed(2)})`;
    }
    ui.count.addEventListener('input', refreshLabels);
    ui.scale.addEventListener('input', refreshLabels);
    ui.speed.addEventListener('input', refreshLabels);
    refreshLabels();

    // scene contents
    let group = new THREE.Group();
    scene.add(group);

    // helper utilities
    function pickPalette(){
      return ui.colors.map(c=>c.value).filter(Boolean);
    }

    function randRange(a,b){ return a + Math.random()*(b-a); }
    function pickColor(palette){ return palette[Math.floor(Math.random()*palette.length)]; }

    // generators
    function createRibbons(count, palette){
      // create tubular ribbon curves
      const objects = [];
      for(let i=0;i<count;i++){
        const points = [];
        const scale = randRange(2,6) * parseFloat(ui.scale.value);
        const waves = Math.floor(randRange(3,10));
        for(let t=0;t<Math.PI*2;t+=Math.PI*2/waves){
          points.push(new THREE.Vector3(
            Math.sin(t*randRange(0.5,1.5))*scale*(0.5+Math.random()),
            Math.cos(t*randRange(0.7,1.3))*scale*(0.2+Math.random()),
            Math.sin(t*randRange(0.8,1.4))*scale*(0.5+Math.random())
          ));
        }
        // smooth
        const curve = new THREE.CatmullRomCurve3(points, true, 'catmullrom', 0.5);
        const geom = new THREE.TubeGeometry(curve, 200, randRange(0.06,0.4)*Math.max(0.3,parseFloat(ui.scale.value)), 8, true);
        const mat = new THREE.MeshStandardMaterial({ color: pickColor(palette), side: THREE.DoubleSide, metalness:0.2, roughness:0.25, emissive:0x000000 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.userData = { speed: randRange(-0.6,0.6), amp: randRange(0.1,0.8) };
        mesh.position.set(randRange(-4,4), randRange(-2,3), randRange(-4,4));
        mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
        group.add(mesh);
        objects.push(mesh);
      }
      return objects;
    }

    function createSpiky(count, palette){
      const objects = [];
      for(let i=0;i<count;i++){
        const radius = randRange(0.6,2.2)*parseFloat(ui.scale.value);
        const ico = new THREE.IcosahedronGeometry(radius, 2);
        // displace vertices
        for(let v=0; v<ico.attributes.position.count; v++){
          const vx = ico.attributes.position.getX(v);
          const vy = ico.attributes.position.getY(v);
          const vz = ico.attributes.position.getZ(v);
          const norm = Math.sqrt(vx*vx+vy*vy+vz*vz);
          const push = 1 + Math.random()*0.6;
          ico.attributes.position.setXYZ(v, vx*push, vy*push, vz*push);
        }
        ico.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: pickColor(palette), metalness:0.6, roughness:0.3, flatShading:false });
        const mesh = new THREE.Mesh(ico, mat);
        mesh.position.set(randRange(-6,6), randRange(-2,4), randRange(-6,6));
        mesh.userData = { rotSpeed: randRange(-0.6,0.6) };
        group.add(mesh);
        objects.push(mesh);
      }
      return objects;
    }

    function createPlanes(count, palette){
      const objects = [];
      for(let i=0;i<count;i++){
        const w = randRange(0.4,3.5)*parseFloat(ui.scale.value);
        const h = randRange(0.4,3)*parseFloat(ui.scale.value);
        const geom = new THREE.PlaneGeometry(w, h, 6, 6);
        // subtle vertex displacement
        const pos = geom.attributes.position;
        for(let j=0;j<pos.count;j++){
          pos.setZ(j, (Math.random()-0.5)*0.4*parseFloat(ui.scale.value));
        }
        geom.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: pickColor(palette), side: THREE.DoubleSide, transparent:true, opacity:randRange(0.4,0.95) });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(randRange(-8,8), randRange(-3,4), randRange(-8,8));
        mesh.rotation.set(randRange(-Math.PI,Math.PI), randRange(-Math.PI,Math.PI), randRange(-Math.PI,Math.PI));
        mesh.userData = { floatSpeed: randRange(0.1,0.6), floatAmp: randRange(0.2,1.6) };
        group.add(mesh);
        objects.push(mesh);
      }
      return objects;
    }

    function createParticles(count, palette){
      // single instanced Points system
      const positions = new Float32Array(count*3);
      const colors = new Float32Array(count*3);
      const paletteLen = palette.length;
      for(let i=0;i<count;i++){
        positions[i*3+0] = randRange(-12,12);
        positions[i*3+1] = randRange(-6,6);
        positions[i*3+2] = randRange(-12,12);
        const col = new THREE.Color(pickColor(palette));
        colors[i*3+0] = col.r;
        colors[i*3+1] = col.g;
        colors[i*3+2] = col.b;
      }
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const mat = new THREE.PointsMaterial({ size: Math.max(0.05, 0.15*parseFloat(ui.scale.value)), vertexColors: true, transparent:true, opacity:0.9 });
      const points = new THREE.Points(geom, mat);
      points.userData = { speed: randRange(0.05,0.7) };
      group.add(points);
      return [points];
    }

    // main generate function
    let currentObjects = [];
    function regenerate(){
      // clear
      while(group.children.length) group.remove(group.children[0]);
      currentObjects.length = 0;

      // background
      scene.background = new THREE.Color(ui.bg.value);

      const palette = pickPalette();
      const cnt = Math.max(1, parseInt(ui.count.value));
      const style = ui.style.value;

      if(style === 'ribbons'){
        currentObjects = createRibbons(cnt, palette);
      } else if(style === 'spiky'){
        currentObjects = createSpiky(cnt, palette);
      } else if(style === 'planes'){
        currentObjects = createPlanes(cnt, palette);
      } else if(style === 'particles'){
        currentObjects = createParticles(cnt, palette);
      }
    }

    // initial generate
    regenerate();

    // animation
    let running = true;
    ui.animateToggle.textContent = 'Pause';
    ui.animateToggle.addEventListener('click', ()=>{
      running = !running;
      ui.animateToggle.textContent = running ? 'Pause' : 'Play';
    });

    ui.regen.addEventListener('click', regenerate);
    ui.randomize.addEventListener('click', ()=>{
      // randomize palette + params
      ui.c1.value = '#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      ui.c2.value = '#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      ui.c3.value = '#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      ui.c4.value = '#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      ui.c5.value = '#'+Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
      ui.bg.value = '#'+Math.floor(Math.random()*0x222222 + 0x001111).toString(16).padStart(6,'0');
      ui.count.value = Math.floor(randRange(12,180));
      ui.scale.value = (Math.random()*2+0.3).toFixed(2);
      refreshLabels();
      regenerate();
    });

    ui.export.addEventListener('click', ()=>{
      renderer.domElement.toBlob(blob=>{
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `abstract-${Date.now()}.png`;
        a.click();
      });
    });

    ui.style.addEventListener('change', regenerate);
    ui.bg.addEventListener('input', ()=> scene.background = new THREE.Color(ui.bg.value));
    ui.count.addEventListener('change', regenerate);
    ui.scale.addEventListener('change', regenerate);

    // animate loop
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      const dt = clock.getDelta() * parseFloat(ui.speed.value);

      if(running){
        // animate objects
        for(const o of group.children){
          if(o.type === 'Mesh'){
            if(o.geometry.type === 'TubeGeometry'){
              o.rotation.x += 0.002 * (o.userData.speed||1) * dt * 60;
              o.rotation.y += 0.002 * (o.userData.speed||1) * dt * 60;
            } else {
              // spiky / plane
              if(o.userData.rotSpeed) o.rotation.y += (o.userData.rotSpeed * 0.01 * (parseFloat(ui.speed.value)||1));
              if(o.userData.floatSpeed){
                o.position.y += Math.sin(t * o.userData.floatSpeed) * 0.002 * (o.userData.floatAmp||1) * dt * 60;
              }
            }
          } else if(o.type === 'Points'){
            // slowly drift particles
            o.rotation.y += 0.001 * (o.userData.speed||1) * dt * 60;
          }
        }
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // handle resize
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // first-time randomize slight nudge
    // (so many palettes don't look identical)
    // no auto-randomize unless user requests
  </script>
</body>
</html>
